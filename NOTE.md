# 1. 索引的作用机制
索引是数据库为了保证查询的高效，额外存储的一些特定结果的数据，这些结构决定了我们在查询时可以以很小的时间复杂度查询到数据，通常是O(log2N)。由于数据库需要额外维护一些数据，因此创建索引会导致在插入和删除时耗费更多的性能开销。


# 2. 单列索引
单列索引好处，更灵活，多条件查询时，查询优化器会选择最优索引策略，多数情况下只会用一个索引。缺点是：会创建多个B+索引树，占用空间是其次，更重要的是会对删除和增加的造成更多的性能开销。

# 3. 多列索引/联合索引
需要注意的是：创建多列索引时，需要正确的指定列的顺序。多列索引会依赖第一列的值进行定位，如果查询的时候不指定第一列的值，则多列索引无法生效。
## 多列索引好处：
1. 创建一个联合索引相当于同时创建了多个索引组合，但它只占用一个索引的空间。它可以节省磁盘空间，减少增删的性能开销。
2. 覆盖索引，如果查询选择的列都在索引上，则可以直接从索引中获得。




# 扩展阅读地址： 
- https://blog.csdn.net/Abysscarry/article/details/80792876
- https://segmentfault.com/a/1190000015416513

# 4. ACID(数据库事务的特性)
- A(Atomicity) 原子性：在一个事务内的多个操作要么都成功要么都失败，具有原子性不可分割。
- C(Consistency) 一致性： 一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。比如外键约束，唯一约束等等。
- I(Isolation) 隔离性：多个事务并发访问时，事务之间是互相隔离的。通过设置不同的隔离级别来保证不同等级的隔离性。
- D(Durability) 持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

# 5. 事务隔离级别

| 隔离级别          | 脏读 | 不可重复读  | 幻读  | 丢失更新 |
| ---------------- | ---- | ---------- | ---- | -------- |
| Read uncommitted | √    | √          | √    | √        |
| Read committed   | ×    | √          | √    | √        |
| Repeatable read  | ×    | ×          | √    | ×        |
| Serializable     | ×    | ×          | ×    | ×        |


- 脏读：一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的。
- 不可重复读：在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。
- 幻读：A对表中所有数据执行修改，在A的修改执行过程中，B插入了新的数据，此时就会表现出A的修改漏掉了一些记录，像是出现了幻觉一般。
- 丢失更新： 两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。（可以通过乐观锁的方式避免此问题）

## 悲观锁与乐观锁
悲观锁：一种独占锁，被当前事务独占，别的事务想要访问该数据只能阻塞等待。比如:for update子句就是悲观锁。

乐观锁：通过加版本号的形式来解决这个问题。每次对数据的任何修改，都会导致版本号的增加，在其他事务对该数据进行操作的时候会验证版本号是否符合预期，如果不符合预期，说明数据取出之后被别的线程做了修改。


# 6. 数据库的分库分表
虽然很多人会将垂直的拆分和水平拆分放一块讲，但是我个人觉得他们不属于同一类型的问题，分属于两个领域。前者属于微服务的拆分范畴，后者是数据分片的范畴。

垂直拆分：具体又分为垂直分库和垂直分表，垂直分库通常是指数据库按照业务模块进行拆分的一种规则。垂直分表是指将一张总表拆分成很多张小表，通过主键关联。

水平拆分：单裤单表太大，最基本的CRUD操作都是问题，查询可能直接超时。最容易的解决办法就是将其切分成一个个的更小区域。不同位置的数据去不同的库或者表进行查询。这通常需要依赖一些标识符，比如时间或者ID，这些标识符会通过一种算法转换成库或者表的后缀，从而定位到具体的库和表。

分库分表的相关文章： https://juejin.im/entry/5b5eb7f2e51d4519700f7d3c

# 7. 数据库中间件
Sharding-JDBC，由当当网开源的一个项目，后面捐赠给apache了。它就是一个客户端的jar包，可以将其理解为一种特殊的JDBC驱动。它提供了数据库/表的分片，路由，除此之外，还提供数据库的读写分离，负载均衡访问规则处理。其实无论读写分离还是负载均衡都可以看作是一种路由器的实现。

除了客户端的中间件，还有服务端的中间件：比如mycat或者sharding-proxy，前者源于阿里开源的cobar的二次开发。后者依旧是sharding-jdbc的兄弟项目，是ShardingSphere的第二个产品。

服务端的proxy相对于客户端来讲，会更加重量级，显然功能也更强大，主要体现为提供了许多跨库的聚合操作的功能。必然会导致的是性能损耗更大，毕竟多一次转发操作。

mycat还支持以下特性：
- 支持XA分布式事务
- 多租户方案
- 基于心跳的自动故障切换
- 全局序列号，解决分布式下的主键生成问题
